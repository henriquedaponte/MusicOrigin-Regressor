import numpy as np
import cvxpy as cp
import pandas as pd


# ====================== Utility Functions ======================

def meanSquaredError(predicted, actual):
    '''
    Calculate the mean squared error (MSE) between predicted and actual values.
    
    Parameters:
    - predicted (numpy array): The array of predicted values generated by the model.
    - actual (numpy array): The array of actual or true values.
    
    Returns:
    - int: The mean squared error, rounded to the nearest whole number, between the predicted and actual values.
    
    Notes:
    The mean squared error is computed as the average of the squared differences between predicted and actual values.
    '''
    
   # Ensure that predicted array is not empty
    if len(predicted) == 0:
        raise ValueError("Predicted array is empty.")
        
    # Ensure that there are no NaN values in predicted and actual arrays
    if np.isnan(predicted).any() or np.isnan(actual).any():
        raise ValueError("NaN values detected in input arrays.")
    
    r = actual - predicted # Residuals
    mse = np.sum(r**2) / len(predicted)
    
    return mse

def preprocessData(filename, lat):
    '''
    Preprocesses the data by loading it, shuffling it, and dividing it into training and test sets.
    
    Parameters:
    filename (str): The path to the CSV file containing the data.
    
    Returns:
    tuple: A tuple containing the following elements:
        X_train (numpy array): The feature matrix for the training data.
        Y_train_lat (numpy array): The latitude values for the training data.
        Y_train_lon (numpy array): The longitude values for the training data.
        X_test (numpy array): The feature matrix for the test data.
        Y_test_lat (numpy array): The latitude values for the test data.
        Y_test_lon (numpy array): The longitude values for the test data.
    
    '''
     
    data = pd.read_csv(filename, delimiter=',')

    # Using 70% of the data for training
    trainDataSize = int(0.7 * data.shape[0])
    trainData = data.iloc[:trainDataSize, :]
    X_train = trainData.iloc[:, :-1].values
    Y_train_lat = (trainData.iloc[:, -2].values).reshape(-1, 1)
    Y_train_lon = (trainData.iloc[:, -1].values).reshape(-1, 1)

    # Using 30% of the data for testing 
    testData = data.iloc[trainDataSize:, :]
    X_test = testData.iloc[:, :-1].values
    Y_test_lat = (testData.iloc[:, -2].values).reshape(-1, 1)
    Y_test_lon = (testData.iloc[:, -1].values).reshape(-1, 1)

    if(lat):
        return X_train, Y_train_lat, X_test, Y_test_lat
    else:
        return X_train, Y_train_lon, X_test, Y_test_lon


def trainModel(X_train, Y_train):

    # Defiing decision variables
    beta = cp.Variable((X_train.shape[1], 1))

    # Defining objective function
    objective = cp.Minimize(cp.sum_squares(Y_train - X_train @ beta))

    # Formulating problem
    problem = cp.Problem(objective)

    # Solving problem
    problem.solve()

    return beta.value

def testModelLat(filename):
     
    X_train, Y_train_lat, X_test, Y_test_lat  = preprocessData(filename, True)

    # Training model
    beta = trainModel(X_train, Y_train_lat)

    # Predicting values for training set
    Y_pred_train = X_train @ beta

    # Calculating the mean squared error for training set
    mse_train_lat = meanSquaredError(Y_pred_train, Y_train_lat)

    # Predicting values for test set
    Y_pred_test = X_test @ beta

    # Calculating the mean squared error for test set
    mse_test_lat = meanSquaredError(Y_pred_test, Y_test_lat)

    # Printing results
    print("Training set mean squared error for Latitude Model: {}".format(mse_train_lat))
    print("Testing set mean squared error for Latitude Model: {}".format(mse_test_lat))
    print("\n")

def testModelLon(filename):

    X_train, Y_train_lon, X_test, Y_test_lon = preprocessData(filename, False)

    # Training model
    beta = trainModel(X_train, Y_train_lon)

    # Predicting values for training set
    Y_pred_train = X_train @ beta

    # Calculating the mean squared error for training set
    mse_train_lon = meanSquaredError(Y_pred_train, Y_train_lon)

    # Predicting values for test set
    Y_pred_test = X_test @ beta

    # Calculating the mean squared error for test set
    mse_test_lon = meanSquaredError(Y_pred_test, Y_test_lon)

    # Printing results

    print("Training set mean squared error for Longitutde Model: {}".format(mse_train_lon))
    print("Testing set mean squared error for Longitutde Model: {}".format(mse_test_lon))
    print("\n")

    

testModelLat('default_plus_chromatic_features_1059_tracks-1.txt')
testModelLon('default_plus_chromatic_features_1059_tracks-1.txt')

