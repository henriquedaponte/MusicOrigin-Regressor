import numpy as np
import cvxpy as cp
import pandas as pd
from sklearn.utils import shuffle


# ====================== Utility Functions ======================

def meanSquaredError(predicted, actual):
    '''
    Calculate the mean squared error (MSE) between predicted and actual values.
    
    Parameters:
    - predicted (numpy array): The array of predicted values generated by the model.
    - actual (numpy array): The array of actual or true values.
    
    Returns:
    - int: The mean squared error, rounded to the nearest whole number, between the predicted and actual values.
    
    Notes:
    The mean squared error is computed as the average of the squared differences between predicted and actual values.
    '''
    
   # Ensure that predicted array is not empty
    if len(predicted) == 0:
        raise ValueError("Predicted array is empty.")
        
    # Ensure that there are no NaN values in predicted and actual arrays
    if np.isnan(predicted).any() or np.isnan(actual).any():
        raise ValueError("NaN values detected in input arrays.")
    
    r = actual - predicted # Residuals
    mse = np.sum(r**2) / len(r)
    
    return mse

def preprocessData(filename, lat):
    '''
    Preprocesses the data by loading it, shuffling it, and dividing it into training and test sets.
    
    Parameters:
    filename (str): The path to the CSV file containing the data.
    
    Returns:
    tuple: A tuple containing the following elements:
        X_train (numpy array): The feature matrix for the training data.
        Y_train_lat (numpy array): The latitude values for the training data.
        Y_train_lon (numpy array): The longitude values for the training data.
        X_test (numpy array): The feature matrix for the test data.
        Y_test_lat (numpy array): The latitude values for the test data.
        Y_test_lon (numpy array): The longitude values for the test data.
    
    '''
     
    data = pd.read_csv(filename, delimiter=',')

    # Using 70% of the data for training
    trainDataSize = int(0.7 * data.shape[0])
    trainData = data.iloc[:trainDataSize, :]
    X_train = trainData.iloc[:, :-2].values
    Y_train_lat = (trainData.iloc[:, -2].values).reshape(-1, 1)
    Y_train_lon = (trainData.iloc[:, -1].values).reshape(-1, 1)

    # Using 30% of the data for testing 
    testData = data.iloc[trainDataSize:, :]
    X_test = testData.iloc[:, :-2].values
    Y_test_lat = (testData.iloc[:, -2].values).reshape(-1, 1)
    Y_test_lon = (testData.iloc[:, -1].values).reshape(-1, 1)

    if(lat):
        return X_train, Y_train_lat, X_test, Y_test_lat
    else:
        return X_train, Y_train_lon, X_test, Y_test_lon
    
def kFoldCrossValidation(filename, k):

    data = pd.read_csv(filename, delimiter=',')
    
    # Calculate the size of each fold
    fold_size = len(data) // k
    
    # Initialize a list to store the mean squared error for each fold
    mse_train_lat = 0
    mse_train_lon = 0
    mse_test_lat = 0
    mse_test_lon = 0
    i = 1
    
    # Perform k-fold cross-validation
    for fold in range(k):
    
        # Define the test data for this fold
        start = fold * fold_size
        end = start + fold_size if fold != (k - 1) else len(data)
        test_data = data.iloc[start:end]
        
        # Define the training data for this fold
        train_data = data.drop(test_data.index)

        # Aloocating proper data for training
        X_train = train_data.iloc[:, :-2].values
        Y_train_lat = (train_data.iloc[:, -2].values).reshape(-1, 1)
        Y_train_lon = (train_data.iloc[:, -1].values).reshape(-1, 1)

        # Allocating proper data for testing
        X_test = test_data.iloc[:, :-2].values
        Y_test_lat = (test_data.iloc[:, -2].values).reshape(-1, 1)
        Y_test_lon = (test_data.iloc[:, -1].values).reshape(-1, 1)
        
        print('=========================================================', '\n')
        print('                  MSE\'s for iteration', i,'k = ', k)
        print('=========================================================', '\n')
        # Training lattitude and longitude models here on training data
        a, b = testModelKFold(X_train, Y_train_lat, X_test, Y_test_lat, True)
        c, d = testModelKFold(X_train, Y_train_lon, X_test, Y_test_lon, False)

        mse_train_lat += a
        mse_test_lat += b
        mse_train_lon += c
        mse_test_lon += d
        i  += 1

    
    # Calculate the average MSE across all folds
    mse_train_lat = mse_train_lat / k
    mse_test_lat = mse_test_lat / k
    mse_train_lon = mse_train_lon / k
    mse_test_lon = mse_test_lon / k

    print("Final training set mean squared error for Latitude Model after k-fold cross validation (k = {}): {}".format(k, mse_train_lat))
    print("Final testing set mean squared error for Latitude Model after k-fold cross validation(k = {}): {}".format(k, mse_test_lat))
    print("\n")
    print("Final training set mean squared error for Longitutde Model after k-fold cross validation(k = {}): {}".format(k, mse_train_lon))
    print("Final testing set mean squared error for Longitutde Model after k-fold cross validation(k = {}): {}".format(k, mse_test_lon))
    print("\n")

def trainModel(X_train, Y_train):

    # Defiing decision variables
    beta = cp.Variable((X_train.shape[1], 1))

    # Defining objective function
    objective = cp.Minimize(cp.sum_squares(Y_train - X_train @ beta))

    # Formulating problem
    problem = cp.Problem(objective)

    # Solving problem
    problem.solve()

    return beta.value

def trainModelLassoUnreg(X_train, Y_train):
    
        # Defiing decision variables
        beta = cp.Variable((X_train.shape[1], 1))
        lambdaCoeff = cp.Variable()
    
        # Defining objective function
        objective = cp.Minimize((cp.sum_squares(Y_train - X_train @ beta) + lambdaCoeff * cp.sum_squares(beta)) / X_train.shape[0])
    
        # Formulating problem
        problem = cp.Problem(objective)
    
        # Solving problem
        problem.solve()
    
        return beta.value, lambdaCoeff.value

def trainModelLassoReg(X_train, Y_train):
    
        # Defiing decision variables
        beta = cp.Variable((X_train.shape[1], 1))
        lambdaCoeff = cp.Variable()
    
        # Defining objective function
        objective = cp.Minimize((cp.sum_squares(Y_train - X_train @ beta) + lambdaCoeff * cp.norm(beta, 1)) / X_train.shape[0])
    
        # Formulating problem
        problem = cp.Problem(objective)
    
        # Solving problem
        problem.solve()
    
        return beta.value, lambdaCoeff.value

def testModel(filename, lat):

    X_train, Y_train, X_test, Y_test = preprocessData(filename, lat)

    # Training model
    beta = trainModel(X_train, Y_train)

    # Predicting values for training set
    Y_pred_train = X_train @ beta

    # Calculating the mean squared error for training set
    mse_train = meanSquaredError(Y_pred_train, Y_train)

    # Predicting values for test set
    Y_pred_test = X_test @ beta

    # Calculating the mean squared error for test set
    mse_test = meanSquaredError(Y_pred_test, Y_test)

    if(lat):
        # Printing results
        print("Training set mean squared error for Latitude Model: {}".format(mse_train))
        print("Testing set mean squared error for Latitude Model: {}".format(mse_test))
        print("\n")
    else:
        # Printing results
        print("Training set mean squared error for Longitutde Model: {}".format(mse_train))
        print("Testing set mean squared error for Longitutde Model: {}".format(mse_test))
        print("\n")
    
    return mse_train, mse_test

def testModelKFold(X_train, Y_train, X_test, Y_test, lat):

    # Training model
    beta = trainModel(X_train, Y_train)

    # Predicting values for training set
    Y_pred_train = X_train @ beta

    # Calculating the mean squared error for training set
    mse_train = meanSquaredError(Y_pred_train, Y_train)

    # Predicting values for test set
    Y_pred_test = X_test @ beta

    # Calculating the mean squared error for test set
    mse_test = meanSquaredError(Y_pred_test, Y_test)

    if(lat):
        # Printing results
        print("Training set mean squared error for Latitude Model: {}".format(mse_train))
        print("Testing set mean squared error for Latitude Model: {}".format(mse_test))
        print("\n")
    else:
        # Printing results
        print("Training set mean squared error for Longitutde Model: {}".format(mse_train))
        print("Testing set mean squared error for Longitutde Model: {}".format(mse_test))
        print("\n")
    
    return mse_train, mse_test
    

# Problem 1.1
mse_train_lat, mse_test_lat = testModel('default_plus_chromatic_features_1059_tracks-1.txt', True)
mse_train_lon, mse_test_lon = testModel('default_plus_chromatic_features_1059_tracks-1.txt', False)

kFoldCrossValidation('default_plus_chromatic_features_1059_tracks-1.txt', 10)
kFoldCrossValidation('default_plus_chromatic_features_1059_tracks-1.txt', 3)


